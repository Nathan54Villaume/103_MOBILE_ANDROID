<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Supervision - Courbes (Demo)</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23ffffff' d='M13 2L4 13.5h6L9 22l9-11.5h-6L13 2z'/%3E%3C/svg%3E">
  
  <!-- Tailwind CSS - DEV only -->
  <script>
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.protocol === 'file:') {
      document.write('<script src="https://cdn.tailwindcss.com"><\/script>');
    }
  </script>
  
  <!-- Chart.js 4.x + adaptateur dates -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
  
  <!-- Icônes SVG -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <symbol id="i-bolt" viewBox="0 0 24 24">
      <polygon points="13 2 4 13.5 10 13.5 9 22 20 9 14 9 13 2" fill="currentColor" />
    </symbol>
    <symbol id="i-refresh" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8">
      <path d="M20 11a8 8 0 1 0-3 5.9L20 18" />
      <path d="M20 14v4h-4" />
    </symbol>
    <symbol id="i-download" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8">
      <path d="M12 3v14" />
      <path d="m7 12 5 5 5-5" />
      <path d="M5 20h14" />
    </symbol>
    <symbol id="i-cog" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3" />
      <path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24" />
    </symbol>
    <symbol id="i-settings" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
      <circle cx="12" cy="12" r="3" />
    </symbol>
  </svg>
  
  <style>
    body { background-color: #0f172a; color: #e2e8f0; }
    .card { 
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 0.75rem;
      backdrop-filter: blur(4px);
    }
    .chart-container {
      height: 320px;
      position: relative;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
    }
    .chart-title {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.125rem;
      font-weight: 600;
    }
    .chart-controls {
      display: flex;
      gap: 0.5rem;
    }
    .timerange-select {
      background: rgba(30, 41, 59, 0.8);
      color: #e2e8f0;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px;
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .timerange-select:hover {
      border-color: rgba(99, 102, 241, 0.6);
      background: rgba(30, 41, 59, 0.9);
    }
    .timerange-select:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    .timerange-select option {
      background: #1e293b;
      color: #e2e8f0;
    }
    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      border: 1px solid transparent;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: #6366f1;
      color: white;
      border-color: #6366f1;
    }
    .btn-primary:hover {
      background: #4f46e5;
      border-color: #4f46e5;
    }
    .btn-secondary {
      background: rgba(148, 163, 184, 0.1);
      color: #e2e8f0;
      border-color: rgba(148, 163, 184, 0.3);
    }
    .btn-secondary:hover {
      background: rgba(148, 163, 184, 0.2);
    }
    .icon {
      width: 1.25rem;
      height: 1.25rem;
    }
    .floating-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      width: 4rem;
      height: 4rem;
      border-radius: 50%;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .floating-btn:hover {
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      transform: scale(1.1) rotate(90deg);
      box-shadow: 0 15px 35px rgba(99, 102, 241, 0.6);
    }
    .floating-btn:active {
      transform: scale(1.05) rotate(90deg);
    }
    
    /* Context Menu Styles - Design moderne et épuré */
    .context-menu {
      font-family: system-ui, -apple-system, sans-serif;
      backdrop-filter: blur(8px);
    }
    .context-menu--open {
      opacity: 1 !important;
      transform: scale(1) translateY(0) !important;
    }
    .context-menu--closing {
      opacity: 0 !important;
      transform: scale(0.95) translateY(-8px) !important;
    }
    
    /* Masquer complètement la scrollbar */
    .context-menu::-webkit-scrollbar {
      display: none;
    }
    .context-menu {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
    }
    
    /* Indicateur de scroll subtil */
    .context-menu-scroll-indicator {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 2px;
      height: 30px;
      background: linear-gradient(to bottom, transparent, #6366f1, transparent);
      border-radius: 1px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .context-menu:hover .context-menu-scroll-indicator {
      opacity: 0.6;
    }
    
    .footer-info {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.875rem;
      color: #94a3b8;
      pointer-events: none;
    }
    .demo-banner {
      background: linear-gradient(90deg, #f59e0b, #d97706);
      color: white;
      text-align: center;
      padding: 0.75rem;
      font-weight: 600;
      font-size: 0.875rem;
    }
  </style>
</head>

<body class="min-h-screen">
  <!-- Bannière de démo -->
        <div class="demo-banner">
          🎯 DEMO - Persistence localStorage - Les zooms + signaux sont sauvegardés ! 🎯
        </div>

  <main class="container mx-auto px-4 py-8 space-y-8">
    <header class="text-center mb-12">
      <h1 class="text-3xl font-bold mb-4">Supervision - Poste Électrique</h1>
      <p class="text-lg text-slate-400">Système de courbes robuste et modulaire</p>
      <div class="mt-4 p-4 bg-blue-900/30 border border-blue-500/30 rounded-lg">
        <h3 class="font-semibold text-blue-200 mb-2">🎮 Instructions de test :</h3>
        <div class="text-sm text-blue-100 space-y-1">
          <p><strong>Pan :</strong> Clic gauche + glisser horizontalement (sans CTRL)</p>
          <p><strong>Zoom :</strong> Molette sur courbe = zoom X, molette sur axe Y = zoom Y</p>
          <p><strong>Reset :</strong> Bouton "Reset" restaure la vue d'origine</p>
          <p><strong>Tactile :</strong> Pincement pour zoom sur les deux axes</p>
        </div>
      </div>
    </header>

    <!-- Carte Transformateur 1 -->
    <section class="card">
      <div class="chart-header">
        <div class="chart-title">
          <svg class="icon" fill="currentColor">
            <use href="#i-bolt"></use>
          </svg>
          Transformateur 1 - Puissance Active
        </div>
        <div class="chart-controls">
          <select class="timerange-select" onchange="changeTimeRange('tr1-power', this.value)" title="Base de temps">
            <option value="15">15 min</option>
            <option value="60" selected>1 heure</option>
            <option value="240">4 heures</option>
            <option value="1440">24 heures</option>
          </select>
          <button type="button" class="btn btn-secondary" onclick="resetChart('tr1-power')">
            <svg class="icon" fill="none" stroke="currentColor">
              <use href="#i-refresh"></use>
            </svg>
            Reset
          </button>
          <button type="button" class="btn btn-secondary" onclick="exportChart('tr1-power')">
            <svg class="icon" fill="none" stroke="currentColor">
              <use href="#i-download"></use>
            </svg>
            Export
          </button>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="chart-tr1-power"></canvas>
      </div>
    </section>

    <!-- Carte Transformateur 2 -->
    <section class="card">
      <div class="chart-header">
        <div class="chart-title">
          <svg class="icon" fill="currentColor">
            <use href="#i-bolt"></use>
          </svg>
          Transformateur 2 - Puissance Active
        </div>
        <div class="chart-controls">
          <select class="timerange-select" onchange="changeTimeRange('tr2-power', this.value)" title="Base de temps">
            <option value="15">15 min</option>
            <option value="60" selected>1 heure</option>
            <option value="240">4 heures</option>
            <option value="1440">24 heures</option>
          </select>
          <button type="button" class="btn btn-secondary" onclick="resetChart('tr2-power')">
            <svg class="icon" fill="none" stroke="currentColor">
              <use href="#i-refresh"></use>
            </svg>
            Reset
          </button>
          <button type="button" class="btn btn-secondary" onclick="exportChart('tr2-power')">
            <svg class="icon" fill="none" stroke="currentColor">
              <use href="#i-download"></use>
            </svg>
            Export
          </button>
        </div>
      </div>
      <div class="chart-container">
        <canvas id="chart-tr2-power"></canvas>
      </div>
    </section>
  </main>

  <!-- Boutons flottants -->
  <div class="floating-buttons fixed bottom-6 right-6 flex flex-col gap-3">
    <!-- Bouton Debug localStorage -->
    <button 
      class="bg-red-600 hover:bg-red-700 text-white p-3 rounded-full shadow-lg transition-colors duration-200" 
      title="Vider localStorage (Debug)"
      onclick="clearLocalStorage()">
      <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
        <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
      </svg>
    </button>
    
    <!-- Bouton Paramètres -->
    <button type="button" class="floating-btn" onclick="openSettings()" title="Ouvrir les paramètres">
      <svg class="icon" style="width: 1.5rem; height: 1.5rem;">
        <use href="#i-settings"></use>
      </svg>
    </button>
  </div>

  <!-- Informations en bas de page -->
  <div class="footer-info">
    <span>Dernière mise à jour : <span id="last-update">--:--:--</span></span>
    <span>N.Villaume</span>
  </div>

  <!-- Script principal - Version inline pour éviter CORS -->
  <script>
    // === CROSSHAIR PLUGIN ===
    const CrosshairPlugin = {
      id: 'crosshair',
      
      defaults: {
        enabled: true,
        color: 'rgba(226, 232, 240, 0.6)',
        width: 1,
        style: 'solid',
        snapToData: false
      },
      
      beforeInit(chart, args, options) {
        chart.crosshair = {
          x: null,
          y: null,
          active: false,
          options: { ...this.defaults, ...options }
        };
      },
      
      afterInit(chart) {
        const canvas = chart.canvas;
        if (!canvas) return;
        
        const updateCrosshair = (event) => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          const chartArea = chart.chartArea;
          const inBounds = x >= chartArea.left && 
                          x <= chartArea.right && 
                          y >= chartArea.top && 
                          y <= chartArea.bottom;
          
          if (inBounds && chart.crosshair.options.enabled) {
            chart.crosshair.x = x;
            chart.crosshair.y = y;
            chart.crosshair.active = true;
            chart.update('none');
          } else {
            chart.crosshair.active = false;
            chart.update('none');
          }
        };
        
        const hideCrosshair = () => {
          chart.crosshair.active = false;
          chart.update('none');
        };
        
        canvas.addEventListener('mousemove', updateCrosshair);
        canvas.addEventListener('mouseleave', hideCrosshair);
        
        chart.crosshair.updateCrosshair = updateCrosshair;
        chart.crosshair.hideCrosshair = hideCrosshair;
      },
      
      beforeDestroy(chart) {
        const canvas = chart.canvas;
        if (!canvas || !chart.crosshair) return;
        
        if (chart.crosshair.updateCrosshair) {
          canvas.removeEventListener('mousemove', chart.crosshair.updateCrosshair);
        }
        if (chart.crosshair.hideCrosshair) {
          canvas.removeEventListener('mouseleave', chart.crosshair.hideCrosshair);
        }
      },
      
      afterDraw(chart) {
        if (!chart.crosshair || !chart.crosshair.active || !chart.crosshair.options.enabled) {
          return;
        }
        
        const ctx = chart.ctx;
        const { x, options } = chart.crosshair;
        const chartArea = chart.chartArea;
        
        if (x === null || !chartArea) return;
        
        ctx.save();
        ctx.strokeStyle = options.color;
        ctx.lineWidth = options.width;
        
        switch (options.style) {
          case 'dashed':
            ctx.setLineDash([5, 5]);
            break;
          case 'dotted':
            ctx.setLineDash([2, 2]);
            break;
          default:
            ctx.setLineDash([]);
        }
        
        ctx.beginPath();
        ctx.moveTo(x, chartArea.top);
        ctx.lineTo(x, chartArea.bottom);
        ctx.stroke();
        
        ctx.restore();
      }
    };

    // === TOOLTIP FORMATTER ===
    class TooltipFormatter {
      static formatTime(timestamp) {
        try {
          const date = new Date(timestamp);
          
          if (isNaN(date.getTime())) {
            return '--:--:--';
          }
          
          const now = new Date();
          const isToday = date.toDateString() === now.toDateString();
          
          if (isToday) {
            return date.toLocaleTimeString('fr-FR', {
              hour: '2-digit',
              minute: '2-digit',  
              second: '2-digit',
              hour12: false
            });
          } else {
            return date.toLocaleString('fr-FR', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            });
          }
        } catch (error) {
          console.warn('[TooltipFormatter] Erreur formatage time:', error);
          return '--:--:--';
        }
      }
      
      static formatValue(value, unit = '', decimals = 2) {
        if (value === null || value === undefined || !Number.isFinite(value)) {
          return `N/A${unit ? ` ${unit}` : ''}`;
        }
        
        let formattedValue;
        let displayUnit = unit;
        
        switch (unit.toLowerCase()) {
          case 'kw':
          case 'kvar':
            if (Math.abs(value) >= 1000) {
              formattedValue = (value / 1000).toFixed(3);
              displayUnit = unit.replace('k', 'M');
            } else {
              formattedValue = value.toFixed(2);
            }
            break;
            
          case 'kwh':
            if (Math.abs(value) >= 1000) {
              formattedValue = (value / 1000).toFixed(2);
              displayUnit = 'MWh';
            } else {
              formattedValue = value.toFixed(1);
            }
            break;
            
          case 'v':
            formattedValue = value.toFixed(1);
            break;
            
          case 'a':
            formattedValue = value.toFixed(1);
            break;
            
          case '':
          case 'pu':
            if (value <= 1.2 && value >= 0) {
              formattedValue = value.toFixed(3);
              displayUnit = displayUnit || 'cos φ';
            } else {
              formattedValue = value.toFixed(decimals);
            }
            break;
            
          default:
            formattedValue = value.toFixed(decimals);
        }
        
        if (Math.abs(parseFloat(formattedValue)) >= 1000) {
          formattedValue = parseFloat(formattedValue).toLocaleString('fr-FR', {
            minimumFractionDigits: formattedValue.includes('.') ? formattedValue.split('.')[1].length : 0,
            maximumFractionDigits: formattedValue.includes('.') ? formattedValue.split('.')[1].length : 0
          });
        }
        
        return `${formattedValue}${displayUnit ? ` ${displayUnit}` : ''}`;
      }
      
      static getTooltipConfig(options = {}) {
        return {
          mode: 'index',
          intersect: false,
          backgroundColor: 'rgba(30, 41, 59, 0.95)',
          titleColor: '#f1f5f9',
          bodyColor: '#e2e8f0',
          borderColor: 'rgba(148,163,184,0.3)',
          borderWidth: 1,
          cornerRadius: 8,
          padding: 12,
          displayColors: true,
          titleFont: {
            size: 13,
            weight: '600'
          },
          bodyFont: {
            size: 12,
            weight: 'normal'
          },
          titleMarginBottom: 8,
          bodySpacing: 6,
          caretPadding: 6,
          ...options,
          callbacks: {
            title: (tooltipItems) => {
              if (!tooltipItems || tooltipItems.length === 0) {
                return '';
              }
              
              const firstItem = tooltipItems[0];
              if (!firstItem || !firstItem.parsed) {
                return '';
              }
              
              return TooltipFormatter.formatTime(firstItem.parsed.x);
            },
            label: (context) => {
              if (!context || !context.dataset) {
                return '';
              }
              
              const dataset = context.dataset;
              const value = context.parsed.y;
              const label = dataset.label || 'Signal';
              const unit = dataset.unit || '';
              
              let decimals = 2;
              if (unit.toLowerCase() === 'v' || unit.toLowerCase() === 'a') {
                decimals = 1;
              } else if (!unit || unit.toLowerCase().includes('pf') || unit.toLowerCase().includes('cos')) {
                decimals = 3;
              }
              
              const formattedValue = TooltipFormatter.formatValue(value, unit, decimals);
              
              return `${label}: ${formattedValue}`;
            },
            ...options.callbacks
          }
        };
      }
    }

    // === PERSISTENCE SERVICE ===
    class PersistenceService {
      constructor() {
        this.storageKey = 'supervision-charts-state';
        this.defaultState = {
          charts: {},
          lastUpdated: null
        };
      }

      /**
       * Sauvegarde l'état d'une courbe
       */
      saveChartState(chartId, state) {
        try {
          const fullState = this.loadState();
          
          if (!fullState.charts[chartId]) {
            fullState.charts[chartId] = {};
          }
          
          // Merger avec l'état existant
          fullState.charts[chartId] = {
            ...fullState.charts[chartId],
            ...state
          };
          
          fullState.lastUpdated = Date.now();
          
          localStorage.setItem(this.storageKey, JSON.stringify(fullState));
          console.log(`[Persistence] État sauvé pour ${chartId}:`, state);
          
        } catch (error) {
          console.error('[Persistence] Erreur sauvegarde:', error);
        }
      }

      /**
       * Charge l'état d'une courbe
       */
      loadChartState(chartId) {
        try {
          const fullState = this.loadState();
          const chartState = fullState.charts[chartId] || {};
          
          console.log(`[Persistence] État chargé pour ${chartId}:`, chartState);
          return chartState;
          
        } catch (error) {
          console.error('[Persistence] Erreur chargement:', error);
          return {};
        }
      }

      /**
       * Sauvegarde le zoom d'une courbe
       */
      saveZoom(chartId, zoomState) {
        this.saveChartState(chartId, { zoom: zoomState });
      }

      /**
       * Sauvegarde les signaux sélectionnés d'une courbe
       */
      saveSignals(chartId, signalIds) {
        this.saveChartState(chartId, { 
          signals: signalIds,
          signalsUpdated: Date.now()
        });
      }

      /**
       * Sauvegarde l'état replié/étendu d'une carte
       */
      saveCardState(chartId, collapsed) {
        this.saveChartState(chartId, { collapsed });
      }

      /**
       * Charge l'état complet depuis localStorage
       */
      loadState() {
        try {
          const stored = localStorage.getItem(this.storageKey);
          if (!stored) return { ...this.defaultState };
          
          const parsed = JSON.parse(stored);
          return {
            ...this.defaultState,
            ...parsed
          };
          
        } catch (error) {
          console.error('[Persistence] Erreur parsing localStorage:', error);
          return { ...this.defaultState };
        }
      }

      /**
       * Efface l'état d'une courbe
       */
      clearChartState(chartId) {
        try {
          const fullState = this.loadState();
          delete fullState.charts[chartId];
          fullState.lastUpdated = Date.now();
          
          localStorage.setItem(this.storageKey, JSON.stringify(fullState));
          console.log(`[Persistence] État effacé pour ${chartId}`);
          
        } catch (error) {
          console.error('[Persistence] Erreur suppression:', error);
        }
      }

      /**
       * Efface tout le localStorage
       */
      clearAllState() {
        try {
          localStorage.removeItem(this.storageKey);
          console.log('[Persistence] Tout le localStorage effacé');
        } catch (error) {
          console.error('[Persistence] Erreur effacement complet:', error);
        }
      }

      /**
       * Retourne des statistiques sur le localStorage
       */
      getStats() {
        try {
          const state = this.loadState();
          const chartCount = Object.keys(state.charts).length;
          const storageSize = new Blob([JSON.stringify(state)]).size;
          
          return {
            chartCount,
            storageSize,
            lastUpdated: state.lastUpdated,
            charts: Object.keys(state.charts)
          };
        } catch (error) {
          return { error: error.message };
        }
      }
    }

    // === SIGNAL SERVICE ===
    class SignalService {
      constructor(baseUrl = '') {
        this.baseUrl = baseUrl;
        this.signalsCache = null;
        this.cacheTimestamp = null;
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
        this.requestTimeout = 10000; // 10 secondes
      }

      async getAvailableSignals() {
        // Vérifier le cache
        if (this.signalsCache && this.cacheTimestamp && 
            (Date.now() - this.cacheTimestamp) < this.cacheTimeout) {
          return this.signalsCache;
        }

        try {
          const signals = this.getFallbackSignals();
          
          // Mettre en cache
          this.signalsCache = signals;
          this.cacheTimestamp = Date.now();
          
          return signals;

        } catch (error) {
          console.error('[SignalService] Erreur récupération signaux:', error);
          return this.getFallbackSignals();
        }
      }

      async getSeriesData(signalIds, from, to) {
        if (!signalIds || signalIds.length === 0) {
          return { datasets: [] };
        }

        try {
          return this.generateFallbackSeries(signalIds, from, to);
        } catch (error) {
          console.error('[SignalService] Erreur récupération séries:', error);
          return this.generateFallbackSeries(signalIds, from, to);
        }
      }

      getFallbackSignals() {
        return [
          { id: 'tr1-power', label: 'TR1 Puissance Active', unit: 'kW', group: 'Transformateurs' },
          { id: 'tr1-reactive', label: 'TR1 Puissance Réactive', unit: 'kVar', group: 'Transformateurs' },
          { id: 'tr1-voltage', label: 'TR1 Tension', unit: 'V', group: 'Transformateurs' },
          { id: 'tr1-current', label: 'TR1 Courant', unit: 'A', group: 'Transformateurs' },
          { id: 'tr2-power', label: 'TR2 Puissance Active', unit: 'kW', group: 'Transformateurs' },
          { id: 'tr2-reactive', label: 'TR2 Puissance Réactive', unit: 'kVar', group: 'Transformateurs' },
          { id: 'tr2-voltage', label: 'TR2 Tension', unit: 'V', group: 'Transformateurs' },
          { id: 'tr2-current', label: 'TR2 Courant', unit: 'A', group: 'Transformateurs' },
          { id: 'line1-power', label: 'Ligne 1 Puissance', unit: 'kW', group: 'Lignes' },
          { id: 'line2-power', label: 'Ligne 2 Puissance', unit: 'kW', group: 'Lignes' },
          { id: 'total-consumption', label: 'Consommation Totale', unit: 'kW', group: 'Global' },
          { id: 'pf-average', label: 'Facteur de Puissance Moyen', unit: 'cos φ', group: 'Global' },
          { id: 'frequency', label: 'Fréquence Réseau', unit: 'Hz', group: 'Réseau' },
          { id: 'temperature', label: 'Température Salle', unit: '°C', group: 'Environnement' },
          { id: 'humidity', label: 'Humidité', unit: '%', group: 'Environnement' }
        ];
      }

      generateFallbackSeries(signalIds, from, to) {
        const datasets = [];
        const colors = this.getSignalColors();
        const signals = this.getFallbackSignals();

        signalIds.forEach((signalId, index) => {
          const signal = signals.find(s => s.id === signalId);
          if (!signal) return;

          // Générer des données réalistes
          const data = this.generateRealisticData(signalId, from, to);
          
          datasets.push({
            label: signal.label,
            unit: signal.unit,
            data: data,
            borderColor: colors[index % colors.length],
            backgroundColor: colors[index % colors.length] + '20',
            pointBackgroundColor: colors[index % colors.length],
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 4,
            tension: 0.1,
            spanGaps: true,
            signalId: signalId
          });
        });

        return { datasets };
      }

      generateRealisticData(signalId, from, to) {
        const points = [];
        const duration = to.getTime() - from.getTime();
        const interval = Math.max(60000, duration / 100); // Au moins 1 min entre points
        
        let baseValue = 100;
        let amplitude = 20;
        
        // Valeurs réalistes selon le type de signal
        if (signalId.includes('power')) {
          baseValue = Math.random() * 500 + 200;
          amplitude = baseValue * 0.3;
        } else if (signalId.includes('voltage')) {
          baseValue = 230 + Math.random() * 20;
          amplitude = 10;
        } else if (signalId.includes('current')) {
          baseValue = Math.random() * 50 + 10;
          amplitude = baseValue * 0.2;
        } else if (signalId.includes('pf')) {
          baseValue = 0.85 + Math.random() * 0.1;
          amplitude = 0.05;
        } else if (signalId.includes('frequency')) {
          baseValue = 50;
          amplitude = 0.1;
        } else if (signalId.includes('temperature')) {
          baseValue = 22 + Math.random() * 8;
          amplitude = 2;
        } else if (signalId.includes('humidity')) {
          baseValue = 45 + Math.random() * 20;
          amplitude = 5;
        }
        
        for (let time = from.getTime(); time <= to.getTime(); time += interval) {
          const t = (time - from.getTime()) / duration;
          const noise = (Math.random() - 0.5) * amplitude * 0.5;
          const trend = Math.sin(t * Math.PI * 4) * amplitude * 0.3;
          const value = baseValue + trend + noise;
          
          points.push({
            x: new Date(time),
            y: Math.max(0, value)
          });
        }
        
        return points;
      }

      getSignalColors() {
        return [
          '#ef4444', // red-500
          '#3b82f6', // blue-500
          '#10b981', // emerald-500
          '#f59e0b', // amber-500
          '#8b5cf6', // violet-500
          '#06b6d4', // cyan-500
          '#84cc16', // lime-500
          '#f97316', // orange-500
          '#ec4899', // pink-500
          '#6366f1', // indigo-500
          '#14b8a6', // teal-500
          '#eab308', // yellow-500
          '#dc2626', // red-600
          '#2563eb', // blue-600
          '#059669'  // emerald-600
        ];
      }
    }

    // === CONTEXT MENU ===
    class ContextMenu {
      constructor(signalService, options = {}) {
        this.signalService = signalService;
        this.options = {
          className: 'context-menu',
          maxHeight: 400,
          animationDuration: 200,
          ...options
        };
        
        this.isOpen = false;
        this.currentMenu = null;
        this.currentChart = null;
        this.onSelectionChange = null;
        this.availableSignals = [];
        
        // Bindings
        this.handleDocumentClick = this.handleDocumentClick.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleSignalToggle = this.handleSignalToggle.bind(this);
        
        this.init();
      }

      init() {
        // Charger les signaux disponibles
        this.loadAvailableSignals();
        
        // Event listeners globaux
        document.addEventListener('click', this.handleDocumentClick);
        document.addEventListener('keydown', this.handleKeyDown);
      }

      async loadAvailableSignals() {
        try {
          console.log('[ContextMenu] Chargement des signaux disponibles...');
          this.availableSignals = await this.signalService.getAvailableSignals();
          console.log('[ContextMenu] Signaux chargés:', this.availableSignals);
          
          if (!this.availableSignals || this.availableSignals.length === 0) {
            console.warn('[ContextMenu] Aucun signal disponible, utilisation de signaux par défaut');
            // Signaux par défaut pour la démo
            this.availableSignals = [
              { id: 'tr1-power', label: 'TR1 Puissance Active', unit: 'kW', group: 'Transformateur 1' },
              { id: 'tr1-reactive', label: 'TR1 Puissance Réactive', unit: 'kVar', group: 'Transformateur 1' },
              { id: 'tr2-power', label: 'TR2 Puissance Active', unit: 'kW', group: 'Transformateur 2' },
              { id: 'tr2-reactive', label: 'TR2 Puissance Réactive', unit: 'kVar', group: 'Transformateur 2' }
            ];
          }
          
        } catch (error) {
          console.error('[ContextMenu] Erreur chargement signaux:', error);
          // Fallback avec signaux par défaut
          this.availableSignals = [
            { id: 'tr1-power', label: 'TR1 Puissance Active', unit: 'kW', group: 'Transformateur 1' },
            { id: 'tr1-reactive', label: 'TR1 Puissance Réactive', unit: 'kVar', group: 'Transformateur 1' },
            { id: 'tr2-power', label: 'TR2 Puissance Active', unit: 'kW', group: 'Transformateur 2' },
            { id: 'tr2-reactive', label: 'TR2 Puissance Réactive', unit: 'kVar', group: 'Transformateur 2' }
          ];
          console.log('[ContextMenu] Utilisation signaux par défaut:', this.availableSignals);
        }
      }

      show(event, chartInstance, currentSignals = [], onSelectionChange = null) {
        event.preventDefault();
        
        // Fermer le menu existant
        this.hide();
        
        // MODAL CAPTIF - Bloquer le scroll de la page
        document.body.style.overflow = 'hidden';
        
        this.currentChart = chartInstance;
        this.onSelectionChange = onSelectionChange;
        
        // Stocker l'état initial pour détecter les changements
        this.initialSignals = [...currentSignals];
        
        // Overlay modal simple (sans flou)
        this.overlay = document.createElement('div');
        this.overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
          background: rgba(0, 0, 0, 0.4);
          z-index: 99998;
          opacity: 0;
          transition: opacity 0.2s ease;
          cursor: pointer;
        `;
        
        // Fermer le menu si on clique sur l'overlay
        this.overlay.addEventListener('click', (e) => {
          if (e.target === this.overlay) {
            this.hide();
          }
        });
        
        document.body.appendChild(this.overlay);
        
        // Animation d'entrée overlay
        requestAnimationFrame(() => {
          this.overlay.style.opacity = '1';
        });
        
        // Créer le menu
        this.currentMenu = this.createMenuElement(currentSignals);
        
        // Positionner le menu
        this.positionMenu(this.currentMenu, event.clientX, event.clientY);
        
        // Ajouter le menu au DOM avec animation d'entrée
        this.currentMenu.style.opacity = '0';
        this.currentMenu.style.transform = 'scale(0.9) translateY(-20px)';
        document.body.appendChild(this.currentMenu);
        
        // Animation d'entrée moderne
        requestAnimationFrame(() => {
          this.currentMenu.style.opacity = '1';
          this.currentMenu.style.transform = 'scale(1) translateY(0)';
        });
        
        this.isOpen = true;
        
        // Empêcher l'ouverture d'autres menus contextuels
        this.preventOtherContextMenus = (e) => {
          if (!this.currentMenu || !document.body.contains(this.currentMenu)) return;
          e.preventDefault();
          e.stopPropagation();
        };
        document.addEventListener('contextmenu', this.preventOtherContextMenus, true);
        
        // DEBUG SUPPRIMÉ - on se concentre sur le menu principal
      }

      hide() {
        if (!this.currentMenu || !this.isOpen) return;
        
        // RESTAURER LE SCROLL DE LA PAGE et nettoyer les listeners
        document.body.style.overflow = '';
        
        // Supprimer le bloqueur de contextmenu
        if (this.preventOtherContextMenus) {
          document.removeEventListener('contextmenu', this.preventOtherContextMenus, true);
          this.preventOtherContextMenus = null;
        }
        
        // Animation de fermeture overlay
        if (this.overlay) {
          this.overlay.style.opacity = '0';
          setTimeout(() => {
            if (this.overlay && this.overlay.parentNode) {
              this.overlay.parentNode.removeChild(this.overlay);
            }
            this.overlay = null;
          }, 200);
        }
        
        // Animation de fermeture menu
        this.currentMenu.style.opacity = '0';
        this.currentMenu.style.transform = 'scale(0.95) translateY(-10px)';
        
        setTimeout(() => {
          if (this.currentMenu && this.currentMenu.parentNode) {
            this.currentMenu.parentNode.removeChild(this.currentMenu);
          }
          this.currentMenu = null;
          this.validateBtn = null;
          this.initialSignals = null;
          this.isOpen = false;
        }, 200);
        
      }

      createMenuElement(currentSignals) {
        const menu = document.createElement('div');
        menu.className = this.options.className;
        menu.setAttribute('role', 'menu');
        menu.setAttribute('aria-label', 'Sélection des signaux');
        
        // Style compact et moderne
        menu.style.cssText = `
          position: fixed;
          z-index: 999999;
          background: #1e293b;
          border: 1px solid #3b82f6;
          border-radius: 8px;
          box-shadow: 0 8px 24px rgba(0,0,0,0.4);
          width: 260px;
          max-height: 400px;
          overflow: hidden;
          opacity: 1;
          display: block;
          font-size: 13px;
          color: #f1f5f9;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
          transition: all 0.15s ease;
        `;
        
        
        
        // En-tête compact
        const header = document.createElement('div');
        header.style.cssText = `
          padding: 12px 16px;
          font-weight: 600;
          font-size: 13px;
          color: #3b82f6;
          background: #0f172a;
          border-bottom: 1px solid #374151;
          border-radius: 8px 8px 0 0;
          display: flex;
          align-items: center;
          gap: 6px;
        `;
        header.innerHTML = '⚡ Signaux';
        menu.appendChild(header);
        
        // Container principal avec hauteur ajustée
        const mainContainer = document.createElement('div');
        mainContainer.style.cssText = `
          display: flex;
          flex-direction: column;
          height: 280px;
        `;
        
        // Zone de scroll compacte
        const scrollContainer = document.createElement('div');
        scrollContainer.style.cssText = `
          overflow-y: auto;
          padding: 8px;
          scrollbar-width: none;
          -ms-overflow-style: none;
        `;
        // Masquer scrollbar WebKit
        scrollContainer.classList.add('hide-scrollbar');
        
        // CSS pour masquer scrollbar WebKit
        if (!document.getElementById('hide-scrollbar-styles')) {
          const style = document.createElement('style');
          style.id = 'hide-scrollbar-styles';
          style.textContent = '.hide-scrollbar::-webkit-scrollbar { width: 0px; }';
          document.head.appendChild(style);
        }
        
        // Grid ultra-compacte
        const signalsGrid = document.createElement('div');
        signalsGrid.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 2px;
        `;
        
        // Créer tous les signaux avec design moderne
        this.availableSignals.forEach((signal, index) => {
          const item = this.createModernSignalItem(signal, currentSignals.includes(signal.id), index);
          signalsGrid.appendChild(item);
        });
        
        // Assembler la structure
        scrollContainer.appendChild(signalsGrid);
        mainContainer.appendChild(scrollContainer);
        menu.appendChild(mainContainer);
        
        // Footer compact
        const footer = document.createElement('div');
        footer.style.cssText = `
          padding: 8px;
          background: #0f172a;
          border-top: 1px solid #374151;
          border-radius: 0 0 8px 8px;
          display: flex;
          gap: 8px;
          flex-shrink: 0;
        `;
        
        // Boutons d'action
        const validateBtn = this.createCompactButton('✓ Valider', () => this.validateSelection(), '#10b981');
        const cancelBtn = this.createCompactButton('✗ Fermer', () => this.hide(), '#6b7280');
        
        // Stocker la référence pour pouvoir l'actualiser
        this.validateBtn = validateBtn;
        this.updateValidateButton();
        
        footer.appendChild(validateBtn);
        footer.appendChild(cancelBtn);
        menu.appendChild(footer);
        
        return menu;
      }

      createModernSignalItem(signal, checked, index) {
        const item = document.createElement('div');
        item.className = 'context-menu__item';
        item.setAttribute('role', 'menuitemcheckbox');
        item.setAttribute('aria-checked', checked);
        item.setAttribute('tabindex', '0');
        item.dataset.signalId = signal.id;
        
        // Couleur unique pour chaque signal
        const colors = [
          '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', 
          '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1',
          '#14b8a6', '#eab308', '#dc2626', '#2563eb', '#059669'
        ];
        const signalColor = colors[index % colors.length];
        
        item.style.cssText = `
          display: flex;
          align-items: center;
          padding: 6px 8px;
          margin: 0;
          background: ${checked ? 'rgba(59, 130, 246, 0.15)' : 'transparent'};
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.15s ease;
          user-select: none;
          gap: 8px;
          position: relative;
        `;
        
        // Dot de couleur compact
        const colorDot = document.createElement('div');
        colorDot.style.cssText = `
          width: 6px;
          height: 6px;
          border-radius: 50%;
          background: ${signalColor};
          flex-shrink: 0;
        `;
        
        // Switch compact
        const checkboxContainer = document.createElement('div');
        checkboxContainer.style.cssText = `
          width: 28px;
          height: 16px;
          background: ${checked ? '#3b82f6' : '#4b5563'};
          border-radius: 8px;
          position: relative;
          transition: all 0.15s ease;
          flex-shrink: 0;
        `;
        
        const checkboxKnob = document.createElement('div');
        checkboxKnob.style.cssText = `
          width: 12px;
          height: 12px;
          background: white;
          border-radius: 50%;
          position: absolute;
          top: 2px;
          left: ${checked ? '14px' : '2px'};
          transition: all 0.15s ease;
          box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        `;
        
        checkboxContainer.appendChild(checkboxKnob);
        
        // Contenu compact (une seule ligne)
        const content = document.createElement('div');
        content.style.cssText = `
          flex: 1;
          overflow: hidden;
        `;
        
        const label = document.createElement('div');
        label.textContent = `${signal.label} ${signal.unit ? `(${signal.unit})` : ''}`;
        label.style.cssText = `
          font-size: 12px;
          font-weight: ${checked ? '500' : '400'};
          color: ${checked ? '#f1f5f9' : '#d1d5db'};
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          line-height: 1.3;
        `;
        
        content.appendChild(label);
        
        // Assemblage
        item.appendChild(colorDot);
        item.appendChild(checkboxContainer);
        item.appendChild(content);
        
        // Events
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          this.handleSignalToggle(signal.id);
        });
        
        item.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.handleSignalToggle(signal.id);
          }
        });
        
        // Hover effects subtils
        item.addEventListener('mouseover', () => {
          item.style.background = checked ? 'rgba(59, 130, 246, 0.2)' : 'rgba(75, 85, 99, 0.3)';
        });
        
        item.addEventListener('mouseout', () => {
          item.style.background = checked ? 'rgba(59, 130, 246, 0.15)' : 'transparent';
        });
        
        item.addEventListener('focus', () => {
          item.style.outline = '2px solid #6366f1';
          item.style.outlineOffset = '1px';
        });
        
        item.addEventListener('blur', () => {
          item.style.outline = 'none';
        });
        
        return item;
      }

      createModernButton(text, onClick, color = '#6366f1') {
        const btn = document.createElement('button');
        btn.innerHTML = text;
        btn.style.cssText = `
          background: linear-gradient(135deg, ${color}, ${color}dd);
          color: white;
          border: none;
          padding: 12px 20px;
          border-radius: 10px;
          font-size: 14px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px ${color}30;
          min-width: 120px;
          text-align: center;
          position: relative;
          overflow: hidden;
        `;
        
        // Click handler avec effet ripple simple
        btn.addEventListener('click', (e) => {
          onClick();
          
          const ripple = document.createElement('div');
          ripple.style.cssText = `
            position: absolute;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: scale(0);
            animation: ripple 0.6s ease-out;
            pointer-events: none;
            left: ${e.offsetX - 25}px;
            top: ${e.offsetY - 25}px;
            width: 50px;
            height: 50px;
          `;
          
          if (!document.getElementById('ripple-css')) {
            const style = document.createElement('style');
            style.id = 'ripple-css';
            style.textContent = '@keyframes ripple { to { transform: scale(4); opacity: 0; } }';
            document.head.appendChild(style);
          }
          
          btn.appendChild(ripple);
          setTimeout(() => ripple.remove(), 600);
        });
        
        btn.addEventListener('mouseover', () => {
          btn.style.transform = 'translateY(-2px)';
          btn.style.boxShadow = `0 8px 20px ${color}40`;
        });
        
        btn.addEventListener('mouseout', () => {
          btn.style.transform = 'translateY(0)';
          btn.style.boxShadow = `0 4px 12px ${color}30`;
        });
        
        return btn;
      }

      createCompactButton(text, onClick, color = '#3b82f6') {
        const btn = document.createElement('button');
        btn.innerHTML = text;
        btn.style.cssText = `
          background: ${color};
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.15s ease;
          flex: 1;
          text-align: center;
        `;
        
        btn.addEventListener('click', onClick);
        
        btn.addEventListener('mouseover', () => {
          btn.style.opacity = '0.8';
          btn.style.transform = 'scale(0.98)';
        });
        
        btn.addEventListener('mouseout', () => {
          btn.style.opacity = '1';
          btn.style.transform = 'scale(1)';
        });
        
        return btn;
      }

      validateSelection() {
        // Récupérer les signaux actuellement sélectionnés dans le menu
        const selectedSignals = Array.from(
          this.currentMenu.querySelectorAll('.context-menu__item[aria-checked="true"]')
        ).map(item => item.dataset.signalId);
        
        // Notifier le changement
        if (this.onSelectionChange) {
          this.onSelectionChange(selectedSignals);
        }
        
        // Fermer le menu
        this.hide();
      }

      // Méthode de compatibilité pour grouper les signaux (même si on ne les utilise plus visuellement)
      groupSignals(signals) {
        // On retourne juste un groupe unique pour simplifier
        return { 'Tous': signals };
      }


      positionMenu(menu, x, y) {
        // Mesurer le menu
        menu.style.left = '-9999px';
        menu.style.top = '-9999px';
        menu.style.opacity = '0';
        document.body.appendChild(menu);
        
        const rect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        document.body.removeChild(menu);
        
        // Calculer position optimale
        let finalX = Math.max(50, Math.min(x, viewportWidth - 400));
        let finalY = Math.max(50, Math.min(y, viewportHeight - 500));
        
        menu.style.left = `${finalX}px`;
        menu.style.top = `${finalY}px`;
        menu.style.opacity = '1';
      }


      handleSignalToggle(signalId) {
        const item = this.currentMenu?.querySelector(`[data-signal-id="${signalId}"]`);
        if (!item) return;
        
        // Déterminer l'état actuel
        const currentlyChecked = item.getAttribute('aria-checked') === 'true';
        const newChecked = !currentlyChecked;
        
        // Mettre à jour l'état
        item.setAttribute('aria-checked', newChecked);
        
        // Vérifier que les éléments existent
        if (item.children.length >= 3) {
          // Mettre à jour le style du switch
          const switchContainer = item.children[1]; // Le deuxième élément (après le dot)
          const switchKnob = switchContainer.children[0];
          
          if (switchContainer && switchKnob) {
            switchContainer.style.background = newChecked ? '#3b82f6' : '#4b5563';
            switchKnob.style.left = newChecked ? '14px' : '2px';
          }
          
          // Mettre à jour le style de l'item
          item.style.background = newChecked ? 'rgba(59, 130, 246, 0.15)' : 'transparent';
          
          // Mettre à jour le texte
          const content = item.children[2]; // Le contenu (après dot et switch)
          if (content && content.children.length >= 1) {
            const label = content.children[0];
            
            if (label) {
              label.style.fontWeight = newChecked ? '500' : '400';
              label.style.color = newChecked ? '#f1f5f9' : '#d1d5db';
            }
          }
        }
        
        // Les changements sont maintenant appliqués seulement avec "Valider"
        // Mettre à jour le bouton Valider si des changements sont détectés
        this.updateValidateButton();
      }

      updateValidateButton() {
        if (!this.validateBtn || !this.currentMenu) return;
        
        // Comparer l'état actuel du menu avec l'état initial
        const currentMenuSignals = Array.from(
          this.currentMenu.querySelectorAll('.context-menu__item[aria-checked="true"]')
        ).map(item => item.dataset.signalId);
        
        // L'état initial est stocké lors de l'ouverture du menu
        const hasChanges = this.hasSelectionChanged(currentMenuSignals);
        
        if (hasChanges) {
          this.validateBtn.style.background = '#059669'; // Vert plus foncé
          this.validateBtn.style.boxShadow = '0 0 8px rgba(5, 150, 105, 0.3)';
          this.validateBtn.innerHTML = '✓ Valider*';
        } else {
          this.validateBtn.style.background = '#10b981'; // Vert normal
          this.validateBtn.style.boxShadow = 'none';
          this.validateBtn.innerHTML = '✓ Valider';
        }
      }
      
      hasSelectionChanged(currentSignals) {
        if (!this.initialSignals) return false;
        
        // Comparer les deux arrays
        if (currentSignals.length !== this.initialSignals.length) return true;
        
        const sortedCurrent = [...currentSignals].sort();
        const sortedInitial = [...this.initialSignals].sort();
        
        return !sortedCurrent.every((signal, index) => signal === sortedInitial[index]);
      }

      handleDocumentClick(event) {
        if (this.isOpen && this.currentMenu && !this.currentMenu.contains(event.target)) {
          this.hide();
        }
      }

      handleKeyDown(event) {
        if (!this.isOpen || !this.currentMenu) return;
        
        switch (event.key) {
          case 'Escape':
            event.preventDefault();
            this.hide();
            break;
            
          case 'ArrowUp':
          case 'ArrowDown':
            event.preventDefault();
            this.navigateItems(event.key === 'ArrowDown' ? 1 : -1);
            break;
        }
      }

      navigateItems(direction) {
        const items = Array.from(this.currentMenu.querySelectorAll('.context-menu__item[tabindex="0"]'));
        const focused = document.activeElement;
        const currentIndex = items.indexOf(focused);
        
        if (currentIndex === -1) {
          const targetIndex = direction > 0 ? 0 : items.length - 1;
          if (items[targetIndex]) {
            items[targetIndex].focus();
          }
        } else {
          let newIndex = currentIndex + direction;
          
          if (newIndex < 0) {
            newIndex = items.length - 1;
          } else if (newIndex >= items.length) {
            newIndex = 0;
          }
          
          if (items[newIndex]) {
            items[newIndex].focus();
          }
        }
      }

      destroy() {
        this.hide();
        document.removeEventListener('click', this.handleDocumentClick);
        document.removeEventListener('keydown', this.handleKeyDown);
      }
    }

    // === INLINE VERSION DE ZoomPanController.js ===
    class ZoomPanController {
      constructor(chartInstance, options = {}) {
        this.chart = chartInstance;
        this.canvas = chartInstance.canvas;
        
        // Configuration
        this.config = {
          pan: {
            enabled: true,
            mode: 'x',
            threshold: 5,
            ...options.pan
          },
          zoom: {
            enabled: true,
            wheel: {
              enabled: true,
              speed: 0.1,
              modifierKey: null
            },
            pinch: {
              enabled: true
            },
            ...options.zoom
          }
        };
        
        // État interne
        this.isPanning = false;
        this.panStart = null;
        this.originalBounds = null;
        
        // Bindings
        this.handleMouseDown = this.handleMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.handleWheel = this.handleWheel.bind(this);
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
        
        this.init();
      }
      
      init() {
        if (!this.canvas) return;
        
        this.canvas.addEventListener('mousedown', this.handleMouseDown);
        this.canvas.addEventListener('mousemove', this.handleMouseMove);
        this.canvas.addEventListener('mouseup', this.handleMouseUp);
        this.canvas.addEventListener('mouseleave', this.handleMouseUp);
        this.canvas.addEventListener('wheel', this.handleWheel, { passive: false });
        
        this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
        this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        this.canvas.addEventListener('touchend', this.handleTouchEnd);
      }
      
      setBounds(bounds) {
        this.originalBounds = bounds;
      }
      
      getRelativePosition(event) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top
        };
      }
      
      isOnYAxis(relativePos) {
        const chartArea = this.chart.chartArea;
        const margin = 60;
        
        return relativePos.x < chartArea.left + margin || 
               relativePos.x > chartArea.right - margin;
      }
      
      handleMouseDown(event) {
        if (!this.config.pan.enabled) return;
        if (event.button !== 0) return;
        
        event.preventDefault();
        
        const pos = this.getRelativePosition(event);
        
        this.isPanning = true;
        this.panStart = {
          x: event.clientX,
          y: event.clientY,
          canvasX: pos.x,
          canvasY: pos.y,
          scaleX: this.chart.scales.x?.min || 0,
          scaleY: this.chart.scales.y?.min || 0
        };
        
        this.canvas.style.cursor = 'grabbing';
      }
      
      handleMouseMove(event) {
        if (!this.isPanning || !this.panStart) return;
        
        event.preventDefault();
        
        const deltaX = event.clientX - this.panStart.x;
        const chartArea = this.chart.chartArea;
        const xScale = this.chart.scales.x;
        
        if (!xScale || !chartArea) return;
        
        const chartWidth = chartArea.right - chartArea.left;
        const currentRange = xScale.max - xScale.min;
        const panFactor = (currentRange / chartWidth) * deltaX;
        
        const newMin = this.panStart.scaleX - panFactor;
        const newMax = newMin + currentRange;
        
        const { clampedMin, clampedMax } = this.clampToBounds(newMin, newMax, 'x');
        
        xScale.options.min = clampedMin;
        xScale.options.max = clampedMax;
        
        this.chart.update('none');
      }
      
      handleMouseUp(event) {
        if (this.isPanning) {
          this.isPanning = false;
          this.panStart = null;
          this.canvas.style.cursor = 'default';
        }
      }
      
      handleWheel(event) {
        if (!this.config.zoom.enabled || !this.config.zoom.wheel.enabled) return;
        
        event.preventDefault();
        
        const pos = this.getRelativePosition(event);
        const isOnY = this.isOnYAxis(pos);
        const zoomAxis = isOnY ? 'y' : 'x';
        
        const scale = this.chart.scales[zoomAxis];
        if (!scale) return;
        
        const direction = event.deltaY > 0 ? 1 : -1;
        const zoomFactor = 1 + (direction * this.config.zoom.wheel.speed);
        
        let pivotValue;
        if (zoomAxis === 'x') {
          pivotValue = scale.getValueForPixel(pos.x);
        } else {
          pivotValue = scale.getValueForPixel(pos.y);
        }
        
        if (!Number.isFinite(pivotValue)) return;
        
        const currentMin = scale.min;
        const currentMax = scale.max;
        const currentRange = currentMax - currentMin;
        const newRange = currentRange * zoomFactor;
        
        const pivotRatio = (pivotValue - currentMin) / currentRange;
        
        const newMin = pivotValue - (newRange * pivotRatio);
        const newMax = pivotValue + (newRange * (1 - pivotRatio));
        
        const { clampedMin, clampedMax } = this.clampToBounds(newMin, newMax, zoomAxis);
        
        scale.options.min = clampedMin;
        scale.options.max = clampedMax;
        
        this.chart.update('none');
      }
      
      handleTouchStart(event) {
        if (!this.config.zoom.pinch.enabled) return;
        
        if (event.touches.length === 2) {
          event.preventDefault();
          
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          
          this.touchState = {
            initialDistance: this.getTouchDistance(touch1, touch2),
            initialMidpoint: this.getTouchMidpoint(touch1, touch2),
            initialScale: {
              x: { min: this.chart.scales.x?.min, max: this.chart.scales.x?.max },
              y: { min: this.chart.scales.y?.min, max: this.chart.scales.y?.max }
            }
          };
        }
      }
      
      handleTouchMove(event) {
        if (!this.config.zoom.pinch.enabled || !this.touchState) return;
        
        if (event.touches.length === 2) {
          event.preventDefault();
          
          const touch1 = event.touches[0];
          const touch2 = event.touches[1];
          
          const currentDistance = this.getTouchDistance(touch1, touch2);
          const zoomFactor = this.touchState.initialDistance / currentDistance;
          
          ['x', 'y'].forEach(axis => {
            const scale = this.chart.scales[axis];
            if (!scale) return;
            
            const initialMin = this.touchState.initialScale[axis].min;
            const initialMax = this.touchState.initialScale[axis].max;
            const initialRange = initialMax - initialMin;
            const newRange = initialRange * zoomFactor;
            
            const center = (initialMin + initialMax) / 2;
            const newMin = center - newRange / 2;
            const newMax = center + newRange / 2;
            
            const { clampedMin, clampedMax } = this.clampToBounds(newMin, newMax, axis);
            
            scale.options.min = clampedMin;
            scale.options.max = clampedMax;
          });
          
          this.chart.update('none');
        }
      }
      
      handleTouchEnd(event) {
        if (event.touches.length < 2) {
          this.touchState = null;
        }
      }
      
      getTouchDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      getTouchMidpoint(touch1, touch2) {
        return {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2
        };
      }
      
      clampToBounds(min, max, axis) {
        if (!this.originalBounds || !this.originalBounds[axis]) {
          return { clampedMin: min, clampedMax: max };
        }
        
        const bounds = this.originalBounds[axis];
        const proposedRange = max - min;
        const maxRange = bounds.max - bounds.min;
        
        let clampedMin = min;
        let clampedMax = max;
        
        if (proposedRange >= maxRange) {
          clampedMin = bounds.min;
          clampedMax = bounds.max;
        } else {
          if (clampedMin < bounds.min) {
            const shift = bounds.min - clampedMin;
            clampedMin += shift;
            clampedMax += shift;
          }
          
          if (clampedMax > bounds.max) {
            const shift = clampedMax - bounds.max;
            clampedMin -= shift;
            clampedMax -= shift;
          }
          
          clampedMin = Math.max(clampedMin, bounds.min);
          clampedMax = Math.min(clampedMax, bounds.max);
        }
        
        return { clampedMin, clampedMax };
      }
      
      resetZoom() {
        if (!this.originalBounds) return;
        
        ['x', 'y'].forEach(axis => {
          const scale = this.chart.scales[axis];
          const bounds = this.originalBounds[axis];
          
          if (scale && bounds) {
            scale.options.min = bounds.min;
            scale.options.max = bounds.max;
          }
        });
        
        this.chart.update('none');
      }
      
      setPanEnabled(enabled) {
        this.config.pan.enabled = enabled;
      }
      
      setZoomEnabled(enabled) {
        this.config.zoom.enabled = enabled;
      }
      
      destroy() {
        if (!this.canvas) return;
        
        this.canvas.removeEventListener('mousedown', this.handleMouseDown);
        this.canvas.removeEventListener('mousemove', this.handleMouseMove);
        this.canvas.removeEventListener('mouseup', this.handleMouseUp);
        this.canvas.removeEventListener('mouseleave', this.handleMouseUp);
        this.canvas.removeEventListener('wheel', this.handleWheel);
        
        this.canvas.removeEventListener('touchstart', this.handleTouchStart);
        this.canvas.removeEventListener('touchmove', this.handleTouchMove);
        this.canvas.removeEventListener('touchend', this.handleTouchEnd);
      }
    }

    // === INLINE VERSION DE ChartHost.js ===
    class ChartHost {
      constructor(canvasId, options = {}) {
        this.canvasId = canvasId;
        this.canvas = document.getElementById(canvasId);
        
        if (!this.canvas) {
          throw new Error(`Canvas #${canvasId} introuvable`);
        }
        
        // ID unique pour cette courbe (basé sur l'ID du canvas)
        this.chartId = canvasId;
        
        // Services
        this.signalService = new SignalService();
        this.persistenceService = new PersistenceService();
        
        // Initialiser le ContextMenu après avoir vérifié que SignalService fonctionne
        try {
          this.contextMenu = new ContextMenu(this.signalService);
          // IMPORTANT: Initialiser le ContextMenu pour charger les signaux disponibles
          this.contextMenu.init();
          console.log('[ChartHost] ContextMenu initialisé pour', this.chartId);
          
        } catch (error) {
          console.error('[ChartHost] Erreur initialisation ContextMenu:', error);
          this.contextMenu = null;
        }
        
        // Options par défaut (thème sombre, décimation, formats)
        this.defaultOptions = {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          parsing: false,
          
          datasets: {
            line: {
              pointRadius: 0,
              pointHoverRadius: 4,
              borderWidth: 2,
              spanGaps: true,
              tension: 0.1
            }
          },
          
          scales: {
            x: {
              type: 'time',
              time: {
                tooltipFormat: 'HH:mm:ss',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm',
                  hour: 'HH:mm',
                  day: 'dd/MM',
                  month: 'MM/yyyy'
                }
              },
              ticks: {
                color: '#e2e8f0',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(148,163,184,0.15)',
                borderColor: 'rgba(148,163,184,0.3)'
              }
            },
            y: {
              ticks: {
                color: '#e2e8f0',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(148,163,184,0.1)',
                borderColor: 'rgba(148,163,184,0.3)'
              }
            }
          },
          
          plugins: {
            legend: {
              display: true,
              labels: {
                color: '#e2e8f0',
                font: { size: 12 }
              }
            },
            tooltip: TooltipFormatter.getTooltipConfig(),
            crosshair: {
              enabled: true,
              color: 'rgba(226, 232, 240, 0.6)',
              width: 1,
              style: 'solid',
              snapToData: false
            }
          },
          
          hover: {
            mode: 'index',
            intersect: false
          }
        };
        
        this.options = this.mergeDeep(this.defaultOptions, options);
        this.chart = null;
        this.originalBounds = null;
        this.datasets = [];
        this.zoomPanController = null;
        this.contextMenu = null;
        this.signalService = null;
        this.currentSignals = [];
        
        this.init();
      }
      
      init() {
        const ctx = this.canvas.getContext('2d');
        
        
        // Enregistrer le plugin crosshair
        Chart.register(CrosshairPlugin);
        
        this.chart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [] },
          options: this.options
        });
        
        // Initialiser le contrôleur zoom/pan
        this.zoomPanController = new ZoomPanController(this.chart, {
          pan: {
            enabled: true,
            mode: 'x'
          },
          zoom: {
            enabled: true,
            wheel: {
              enabled: true,
              speed: 0.1
            },
            pinch: {
              enabled: true
            }
          }
        });
        
        // Les services sont déjà initialisés dans le constructeur
        
        // Binder la méthode
        this.handleContextMenu = this.handleContextMenu.bind(this);
        
        // Event listener pour clic droit
        this.canvas.addEventListener('contextmenu', this.handleContextMenu);
        console.log('[ChartHost] Menu contextuel configuré pour', this.chartId);
        
        // Charger l'état sauvegardé (AVANT setup des événements)
        try {
          this.loadSavedState();
          console.log('[ChartHost] État sauvegardé chargé pour', this.chartId);
        } catch (error) {
          console.error('[ChartHost] Erreur chargement état sauvé:', error);
        }
        
        // Événements pour la persistence du zoom (APRÈS création du chart)
        try {
          this.setupPersistenceEvents();
        } catch (error) {
          console.error('[ChartHost] Erreur setup événements persistence:', error);
        }
      }
      
      setData(datasets) {
        if (!Array.isArray(datasets)) {
          console.warn('[ChartHost] setData: datasets doit être un array');
          return;
        }
        
        this.datasets = datasets;
        this.chart.data.datasets = [...datasets];
        this.calculateBounds();
        this.chart.update('none');
        
        // Mettre à jour le titre de la courbe
        this.updateChartTitle();
        
        // Sauvegarder les signaux sélectionnés
        const signalIds = datasets
          .map(dataset => dataset.signalId)
          .filter(id => id); // Filtrer les undefined/null
          
        if (signalIds.length > 0) {
          this.persistenceService.saveSignals(this.chartId, signalIds);
        }
        
        // Appliquer le zoom en attente (si on vient de charger depuis localStorage)
        setTimeout(() => {
          this.applyPendingZoom();
        }, 100); // Délai pour laisser Chart.js finir le rendu
      }
      
      calculateBounds() {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        
        this.datasets.forEach(dataset => {
          if (!Array.isArray(dataset.data)) return;
          
          dataset.data.forEach(point => {
            if (!point || typeof point.x === 'undefined' || typeof point.y === 'undefined') return;
            
            const x = new Date(point.x).getTime();
            const y = Number(point.y);
            
            if (Number.isFinite(x)) {
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
            }
            
            if (Number.isFinite(y)) {
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
          });
        });
        
        const yRange = maxY - minY;
        const yMargin = yRange * 0.05;
        
        this.originalBounds = {
          x: { min: minX, max: maxX },
          y: { min: minY - yMargin, max: maxY + yMargin }
        };
        
        // Transmettre les bornes au contrôleur zoom/pan
        if (this.zoomPanController) {
          this.zoomPanController.setBounds(this.originalBounds);
        }
      }
      
      resetView() {
        if (this.zoomPanController) {
          // Utiliser le reset du contrôleur pour une cohérence
          this.zoomPanController.resetZoom();
        } else if (this.originalBounds) {
          // Fallback si pas de contrôleur
          this.chart.options.scales.x.min = this.originalBounds.x.min;
          this.chart.options.scales.x.max = this.originalBounds.x.max;
          this.chart.options.scales.y.min = this.originalBounds.y.min;
          this.chart.options.scales.y.max = this.originalBounds.y.max;

          this.chart.update('none');
        }
        
        // Effacer le zoom sauvegardé
        this.persistenceService.saveZoom(this.chartId, null);
      }
      
      getView() {
        const scales = this.chart.scales;
        return {
          x: { 
            min: scales.x?.min || this.originalBounds?.x.min,
            max: scales.x?.max || this.originalBounds?.x.max
          },
          y: { 
            min: scales.y?.min || this.originalBounds?.y.min,
            max: scales.y?.max || this.originalBounds?.y.max
          }
        };
      }
      
      setView(range) {
        if (!range || typeof range !== 'object') return;
        
        if (range.x) {
          if (range.x.min !== undefined) this.chart.options.scales.x.min = range.x.min;
          if (range.x.max !== undefined) this.chart.options.scales.x.max = range.x.max;
        }
        
        if (range.y) {
          if (range.y.min !== undefined) this.chart.options.scales.y.min = range.y.min;
          if (range.y.max !== undefined) this.chart.options.scales.y.max = range.y.max;
        }
        
        this.chart.update('none');
      }
      
      /**
       * Configure les événements de persistence 
       */
      setupPersistenceEvents() {
        if (!this.chart) {
          console.warn('[ChartHost] setupPersistenceEvents: chart pas encore créé');
          return;
        }
        
        console.log('[ChartHost] setupPersistenceEvents: Configuration des événements');
        
        // MÉTHODE SIMPLE: Sauvegarder sur les événements de la souris/touch
        // Plutôt que d'interférer avec Chart.js
        if (this.canvas) {
          // Sauvegarder le zoom après mouseup (fin de pan)
          this.canvas.addEventListener('mouseup', () => {
            setTimeout(() => this.saveCurrentZoom(), 150);
          });
          
          // Sauvegarder le zoom après wheel (fin de zoom)
          this.canvas.addEventListener('wheel', () => {
            setTimeout(() => this.saveCurrentZoom(), 150);
          });
          
          // Sauvegarder après touchend (fin de pinch-to-zoom)
          this.canvas.addEventListener('touchend', () => {
            setTimeout(() => this.saveCurrentZoom(), 150);
          });
        }
      }
      
      /**
       * Sauvegarde le zoom actuel
       */
      saveCurrentZoom() {
        const view = this.getView();
        if (view && view.x && view.y) {
          this.persistenceService.saveZoom(this.chartId, view);
        }
      }
      
      /**
       * Charge l'état sauvegardé (zoom + signaux)
       */
      loadSavedState() {
        const savedState = this.persistenceService.loadChartState(this.chartId);
        
        // Le zoom sera restauré après le chargement des données
        if (savedState.zoom) {
          console.log(`[ChartHost] Zoom sauvé trouvé pour ${this.chartId}:`, savedState.zoom);
          this.pendingZoom = savedState.zoom;
        }
        
        // Charger les signaux sauvegardés (APRÈS l'init complète)
        if (savedState.signals && Array.isArray(savedState.signals)) {
          console.log(`[ChartHost] Signaux sauvés trouvés pour ${this.chartId}:`, savedState.signals);
          // Différer le chargement pour ne pas bloquer l'initialisation
          setTimeout(() => {
            this.loadSignalData(savedState.signals);
          }, 100);
        }
      }
      
      /**
       * Applique le zoom en attente (après chargement des données)
       */
      applyPendingZoom() {
        if (this.pendingZoom && this.chart) {
          try {
            this.setView(this.pendingZoom);
            console.log(`[ChartHost] Zoom restauré pour ${this.chartId}`);
            this.pendingZoom = null;
          } catch (error) {
            console.warn(`[ChartHost] Erreur restauration zoom:`, error);
          }
        }
      }
      
      /**
       * Charge les données des signaux spécifiés
       */
      async loadSignalData(signalIds) {
        if (!Array.isArray(signalIds) || signalIds.length === 0) {
          this.setData([]);
          return;
        }
        
        try {
          // Vérifier que le service est disponible
          if (!this.signalService || typeof this.signalService.getSeriesData !== 'function') {
            console.warn('[ChartHost] SignalService non disponible, utilisation fallback');
            this.loadFallbackData(signalIds);
            return;
          }
          
          // Récupérer les données depuis l'API
          const series = await this.signalService.getSeriesData(signalIds);
          
          if (series && Array.isArray(series)) {
            this.setData(series);
          } else {
            console.warn(`[ChartHost] Données invalides reçues pour ${signalIds}`);
            this.loadFallbackData(signalIds);
          }
          
        } catch (error) {
          console.error(`[ChartHost] Erreur chargement données:`, error);
          
          // Fallback avec données de test si disponibles
          this.loadFallbackData(signalIds);
        }
      }
      
      /**
       * Fallback avec données de test
       */
      loadFallbackData(signalIds) {
        console.log(`[ChartHost] Fallback données test pour:`, signalIds);
        
        // Vérifier que TestDataGenerator est disponible
        if (!window.TestDataGenerator) {
          console.error(`[ChartHost] TestDataGenerator non disponible !`);
          return;
        }
        
        console.log(`[ChartHost] TestDataGenerator trouvé, génération de ${signalIds.length} signaux`);
        const testData = [];
        
        signalIds.forEach((signalId, index) => {
            console.log(`[ChartHost] Génération données pour signalId: ${signalId}`);
            let dataset;
            
            switch (signalId) {
              case 'tr1-power':
                dataset = TestDataGenerator.generateSineWave('TR1 Puissance Active', '#6366f1', 120, 80, 420);
                dataset.signalId = 'tr1-power';
                testData.push(dataset);
                console.log(`[ChartHost] Dataset TR1 Power ajouté`);
                break;
              case 'tr1-reactive':
                dataset = TestDataGenerator.generateSineWave('TR1 Puissance Réactive', '#f97316', 120, 30, 120);
                dataset.unit = 'kVar';
                dataset.signalId = 'tr1-reactive';
                testData.push(dataset);
                console.log(`[ChartHost] Dataset TR1 Reactive ajouté`);
                break;
              case 'tr2-power':
                dataset = TestDataGenerator.generateSineWave('TR2 Puissance Active', '#f43f5e', 120, 75, 470);
                dataset.signalId = 'tr2-power';
                testData.push(dataset);
                console.log(`[ChartHost] Dataset TR2 Power ajouté`);
                break;
              case 'tr2-reactive':
                dataset = TestDataGenerator.generateSineWave('TR2 Puissance Réactive', '#f59e0b', 120, 35, 110);
                dataset.unit = 'kVar';
                dataset.signalId = 'tr2-reactive';
                testData.push(dataset);
                console.log(`[ChartHost] Dataset TR2 Reactive ajouté`);
                break;
              default:
                console.warn(`[ChartHost] Signal ID inconnu: ${signalId}`);
            }
          });
          
          console.log(`[ChartHost] Données générées (${testData.length} datasets):`, testData.map(d => d.label));
          
          if (testData.length > 0) {
            console.log(`[ChartHost] Appel de setData() avec ${testData.length} datasets`);
            this.setData(testData);
            
            // Recalculer les bounds pour inclure tous les nouveaux signaux
            this.calculateBounds();
            
            // Mettre à jour les scales
            if (this.chart.options.scales.x) {
              this.chart.options.scales.x.min = this.originalBounds.x.min;
              this.chart.options.scales.x.max = this.originalBounds.x.max;
            }
            if (this.chart.options.scales.y) {
              this.chart.options.scales.y.min = this.originalBounds.y.min;
              this.chart.options.scales.y.max = this.originalBounds.y.max;
            }
            
            // Forcer la mise à jour avec les nouvelles bounds
            this.chart.update('active');
            
            console.log(`[ChartHost] setData() terminé avec remise à l'échelle`);
          } else {
            console.warn(`[ChartHost] Aucune donnée générée pour:`, signalIds);
          }
        }
      
      /**
       * Gère le clic droit sur le canvas
       */
      handleContextMenu(event) {
        console.log('[ChartHost] handleContextMenu appelé pour', this.chartId, event);
        console.log('[ChartHost] Etat actuel - contextMenu:', this.contextMenu);
        console.log('[ChartHost] Etat actuel - signalService:', this.signalService);
        
        if (!this.contextMenu) {
          console.error('[ChartHost] contextMenu non initialisé !');
          console.error('[ChartHost] Tentative de re-création du ContextMenu...');
          
          // Tentative de re-création si possible
          try {
            this.contextMenu = new ContextMenu(this.signalService);
            this.contextMenu.init(); // Charger les signaux disponibles
            console.log('[ChartHost] ContextMenu re-créé avec succès');
          } catch (error) {
            console.error('[ChartHost] Erreur re-création ContextMenu:', error);
            return;
          }
        }
        
        // Extraire les IDs des signaux actuellement affichés sur cette courbe
        const currentSignalIds = this.datasets.map(dataset => {
          // Essayer d'abord signalId, puis mapper depuis le label
          return dataset.signalId || this.mapLabelToSignalId(dataset.label);
        }).filter(Boolean);
        
        console.log(`[ChartHost] Menu contextuel pour ${this.canvasId} avec signaux:`, currentSignalIds);
        
        this.contextMenu.show(
          event, 
          this.chart, 
          currentSignalIds, 
          (selectedSignalIds) => this.onSignalSelectionChange(selectedSignalIds)
        );
      }
      
      /**
       * Mappe un label de dataset vers son ID de signal correspondant
       */
      mapLabelToSignalId(label) {
        const labelToIdMap = {
          'Puissance TR1': 'tr1-power',
          'Puissance Réactive TR1': 'tr1-reactive', 
          'TR1 Puissance Active': 'tr1-power',
          'TR1 Puissance Réactive': 'tr1-reactive',
          'Puissance TR2': 'tr2-power',
          'Puissance Réactive TR2': 'tr2-reactive',
          'TR2 Puissance Active': 'tr2-power', 
          'TR2 Puissance Réactive': 'tr2-reactive'
        };
        
        return labelToIdMap[label] || label.toLowerCase().replace(/\s+/g, '-');
      }
      
      /**
       * Gère le changement de sélection des signaux
       */
      async onSignalSelectionChange(selectedSignalIds) {
        console.log(`[ChartHost] Changement signaux pour ${this.chartId}:`, selectedSignalIds);
        
        if (!selectedSignalIds || selectedSignalIds.length === 0) {
          // Vider le graphique si aucun signal sélectionné
          this.setData([]);
          return;
        }
        
        // Sauvegarder le zoom actuel
        const currentView = this.getView();
        
        try {
          // Utiliser loadSignalData qui gère déjà les fallbacks
          await this.loadSignalData(selectedSignalIds);
          
          // Restaurer le zoom si il y en avait un
          if (currentView && (currentView.x.min !== undefined || currentView.y.min !== undefined)) {
            setTimeout(() => {
              this.setView(currentView);
              console.log(`[ChartHost] Zoom restauré après changement signaux`);
            }, 100);
          }
          
        } catch (error) {
          console.error(`[ChartHost] Erreur chargement signaux sélectionnés:`, error);
        }
      }
      
      /**
       * Obtient les signaux actuellement sélectionnés
       */
      getCurrentSignals() {
        return [...this.currentSignals];
      }
      
      /**
       * Met à jour le titre de la courbe basé sur les signaux affichés
       */
      updateChartTitle() {
        // Trouver l'élément titre de la carte
        const canvas = this.canvas;
        const card = canvas.closest('.card');
        if (!card) return;
        
        const titleElement = card.querySelector('.chart-title');
        if (!titleElement) return;
        
        if (!this.datasets || this.datasets.length === 0) {
          // Aucun signal - afficher un titre par défaut
          const iconSvg = titleElement.querySelector('svg');
          titleElement.innerHTML = '';
          if (iconSvg) {
            titleElement.appendChild(iconSvg);
          }
          titleElement.appendChild(document.createTextNode('Aucun signal sélectionné'));
          titleElement.style.opacity = '0.6';
          return;
        }
        
        // Restaurer l'opacité normale
        titleElement.style.opacity = '1';
        
        // Générer le titre basé sur les signaux
        let title = '';
        const signalLabels = this.datasets.map(d => d.label);
        
        if (signalLabels.length === 1) {
          title = `⚡ ${signalLabels[0]}`;
        } else if (signalLabels.length <= 3) {
          title = `⚡ ${signalLabels.join(' + ')}`;
        } else {
          // Grouper par type de signal si possible
          const groups = this.groupSignalsByType(signalLabels);
          if (groups.length === 1) {
            title = `⚡ ${groups[0]} (${signalLabels.length})`;
          } else {
            title = `⚡ ${signalLabels.length} signaux`;
          }
        }
        
        // Mettre à jour le titre en préservant l'icône
        const iconSvg = titleElement.querySelector('svg');
        titleElement.innerHTML = '';
        if (iconSvg) {
          titleElement.appendChild(iconSvg);
        }
        titleElement.appendChild(document.createTextNode(title.replace('⚡ ', '')));
      }
      
      /**
       * Groupe les signaux par type pour un affichage plus intelligent
       */
      groupSignalsByType(labels) {
        const groups = new Set();
        
        labels.forEach(label => {
          if (label.includes('Puissance')) {
            groups.add('Puissance');
          } else if (label.includes('Tension')) {
            groups.add('Tension');
          } else if (label.includes('Courant')) {
            groups.add('Courant');
          } else if (label.includes('Ligne')) {
            groups.add('Lignes');
          } else {
            groups.add('Signaux');
          }
        });
        
        return Array.from(groups);
      }
      
      destroy() {
        // Cleanup du menu contextuel
        if (this.contextMenu) {
          this.contextMenu.destroy();
          this.contextMenu = null;
        }
        
        if (this.zoomPanController) {
          this.zoomPanController.destroy();
          this.zoomPanController = null;
        }
        
        if (this.chart) {
          this.chart.destroy();
          this.chart = null;
        }
        
        // Cleanup event listeners
        if (this.canvas) {
          this.canvas.removeEventListener('contextmenu', this.handleContextMenu);
        }
        
      }
      
      mergeDeep(target, source) {
        const result = { ...target };
        
        for (const key in source) {
          if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
            result[key] = this.mergeDeep(result[key] || {}, source[key]);
          } else {
            result[key] = source[key];
          }
        }
        
        return result;
      }
    }

    // === GESTIONNAIRE GLOBAL ===
    const chartInstances = new Map();
    
    function initChart(cardId, canvasId, config = {}) {
      try {
        if (chartInstances.has(cardId)) {
          console.warn(`[Charts] Carte ${cardId} déjà initialisée`);
          return chartInstances.get(cardId);
        }
        
        const chartHost = new ChartHost(canvasId, config.options);
        
        chartInstances.set(cardId, {
          host: chartHost,
          config: config,
          cardId: cardId,
          canvasId: canvasId
        });
        
        console.log(`[Charts] Carte ${cardId} initialisée`);
        return chartInstances.get(cardId);
        
      } catch (error) {
        console.error(`[Charts] Erreur lors de l'initialisation de ${cardId}:`, error);
        return null;
      }
    }
    
    function updateChart(cardId, datasets) {
      const instance = chartInstances.get(cardId);
      if (!instance) {
        console.warn(`[Charts] Carte ${cardId} non trouvée pour mise à jour`);
        return false;
      }
      
      instance.host.setData(datasets);
      return true;
    }
    
    
    // === GÉNÉRATEUR DE DONNÉES TEST ===
    const TestDataGenerator = {
      generateSineWave(label, color, points = 100, amplitude = 100, offset = 0, frequency = 0.1, minutes = 60) {
        const data = [];
        const now = Date.now();
        const timeSpan = minutes * 60 * 1000; // Fenêtre temporelle en ms
        
        for (let i = 0; i < points; i++) {
          const x = now - timeSpan + (i * timeSpan / points);
          const normalizedTime = (i / points) * frequency * 10;
          const y = offset + amplitude * Math.sin(normalizedTime) + (Math.random() - 0.5) * (amplitude * 0.1);
          
          data.push({ x: x, y: Number(Math.max(0, y).toFixed(2)) });
        }
        
        return {
          label: label,
          data: data,
          borderColor: color,
          backgroundColor: 'transparent',
          unit: 'kW',
          signalId: label.toLowerCase().replace(/\s+/g, '-')
        };
      },
      
      generateTR1Data() {
        const data1 = this.generateSineWave('TR1 Puissance Active', '#6366f1', 120, 80, 420);
        const data2 = this.generateSineWave('TR1 Puissance Réactive', '#f97316', 120, 30, 120);
        
        // S'assurer que les signalId correspondent aux IDs dans SignalService
        data1.signalId = 'tr1-power';
        data2.signalId = 'tr1-reactive';
        data2.unit = 'kVar';
        
        return [data1, data2];
      },
      
      generateTR2Data() {
        const data1 = this.generateSineWave('TR2 Puissance Active', '#f43f5e', 120, 75, 470);
        const data2 = this.generateSineWave('TR2 Puissance Réactive', '#f59e0b', 120, 35, 110);
        
        // S'assurer que les signalId correspondent aux IDs dans SignalService  
        data1.signalId = 'tr2-power';
        data2.signalId = 'tr2-reactive';
        data2.unit = 'kVar';
        
        return [data1, data2];
      }
    };
    
    // Assigner TestDataGenerator à window pour qu'il soit accessible globalement
    window.TestDataGenerator = TestDataGenerator;

    // === FONCTIONS GLOBALES EXPOSÉES ===
    // Fonction Reset globale
    window.resetChart = (cardId) => {
      console.log(`🔄 Tentative de reset pour ${cardId}`);
      const instance = chartInstances.get(cardId);
      if (!instance) {
        console.error(`❌ Carte ${cardId} non trouvée pour reset`);
        return false;
      }
      
      try {
        instance.host.resetView();
        console.log(`✅ Reset de la carte ${cardId} réussi`);
        return true;
      } catch (error) {
        console.error(`❌ Erreur lors du reset de ${cardId}:`, error);
        return false;
      }
    };

    // Fonction Export globale  
    window.exportChart = (cardId) => {
      console.log(`📊 Export demandé pour ${cardId}`);
      const instance = chartInstances.get(cardId);
      if (!instance) {
        console.error(`❌ Carte ${cardId} non trouvée pour export`);
        return false;
      }
      
      try {
        // Export PNG du canvas
        const canvas = instance.host.canvas;
        const url = canvas.toDataURL('image/png', 1.0);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${cardId}-${new Date().toISOString().slice(0, 16).replace(':', '-')}.png`;
        link.click();
        console.log(`✅ Export PNG de ${cardId} réussi`);
        return true;
      } catch (error) {
        console.error(`❌ Erreur lors de l'export de ${cardId}:`, error);
        return false;
      }
    };

    // === GESTION BASE DE TEMPS ===
    window.changeTimeRange = function(chartId, minutes) {
      console.log(`⏱️ Changement base de temps pour ${chartId}: ${minutes} minutes`);
      
      const instance = chartInstances.get(chartId);
      if (!instance) {
        console.warn(`❌ Carte ${chartId} non trouvée pour changement de base de temps`);
        return;
      }
      
      // Sauvegarder la sélection dans localStorage
      try {
        const storageKey = `timerange-${chartId}`;
        localStorage.setItem(storageKey, minutes.toString());
        console.log(`💾 Base de temps sauvée: ${storageKey} = ${minutes}`);
      } catch (error) {
        console.warn(`⚠️ Erreur sauvegarde localStorage:`, error);
      }
      
      // Recharger les données avec la nouvelle base de temps
      loadChartsWithTimeRange(chartId, parseInt(minutes));
    };

    function loadChartsWithTimeRange(chartId, minutes) {
      console.log(`🔄 Rechargement données pour ${chartId} avec ${minutes} minutes`);
      
      // Générer de nouvelles données selon la base de temps
      const datasets = generateDataForTimeRange(chartId, minutes);
      if (datasets && datasets.length > 0) {
        const instance = chartInstances.get(chartId);
        if (instance && instance.host) {
          // Mettre à jour les données
          instance.host.setData(datasets);
          
          // Recalculer et mettre à jour les bounds de l'axe X
          const chart = instance.host.chart;
          if (chart && chart.options && chart.options.scales && chart.options.scales.x) {
            const now = Date.now();
            const timeSpan = minutes * 60 * 1000;
            
            // Forcer les nouvelles limites de l'axe X
            chart.options.scales.x.min = now - timeSpan;
            chart.options.scales.x.max = now;
            
            // Adapter l'unité de temps selon la durée
            if (minutes <= 15) {
              chart.options.scales.x.time.unit = 'minute';
              chart.options.scales.x.time.stepSize = 1;
            } else if (minutes <= 60) {
              chart.options.scales.x.time.unit = 'minute';
              chart.options.scales.x.time.stepSize = 5;
            } else if (minutes <= 240) {
              chart.options.scales.x.time.unit = 'hour';
              chart.options.scales.x.time.stepSize = 1;
            } else {
              chart.options.scales.x.time.unit = 'hour';
              chart.options.scales.x.time.stepSize = 4;
            }
            
            // Reset l'état de zoom pour éviter les conflits
            if (instance.host.resetView) {
              // Sauvegarder les nouvelles limites avant le reset
              const savedMin = chart.options.scales.x.min;
              const savedMax = chart.options.scales.x.max;
              
              // Effectuer le reset pour nettoyer l'état
              instance.host.resetView();
              
              // Rétablir les bonnes limites
              chart.options.scales.x.min = savedMin;
              chart.options.scales.x.max = savedMax;
            }
            
            // Forcer la mise à jour du chart
            chart.update('active');
            
            console.log(`✅ Axe X mis à jour: ${new Date(now - timeSpan).toLocaleTimeString()} → ${new Date(now).toLocaleTimeString()}`);
          }
        }
        console.log(`✅ Données et axes mis à jour pour ${chartId} (${datasets.length} datasets)`);
      } else {
        console.warn(`⚠️ Aucune donnée générée pour ${chartId}`);
      }
    }

    function generateDataForTimeRange(chartId, minutes) {
      // Adapter le nombre de points selon la base de temps
      let pointCount = 100;
      let amplitude = 100;
      let frequency = 0.1;
      
      switch (minutes) {
        case 15:
          pointCount = 60;   // 1 point par 15 secondes
          frequency = 0.2;   // Plus de variations
          break;
        case 60:
          pointCount = 120;  // 1 point par 30 secondes  
          frequency = 0.15;  // Variations moyennes
          break;
        case 240:
          pointCount = 240;  // 1 point par minute
          frequency = 0.1;   // Moins de variations
          break;
        case 1440:
          pointCount = 360;  // 1 point par 4 minutes
          frequency = 0.05;  // Très peu de variations
          amplitude = 120;   // Plus d'amplitude sur 24h
          break;
      }
      
      if (chartId === 'tr1-power') {
        return [
          TestDataGenerator.generateSineWave('TR1 Puissance Active', '#6366f1', pointCount, amplitude, 420, frequency, minutes),
          TestDataGenerator.generateSineWave('TR1 Puissance Réactive', '#f97316', pointCount, amplitude * 0.3, 120, frequency * 0.8, minutes)
        ];
      } else if (chartId === 'tr2-power') {
        return [
          TestDataGenerator.generateSineWave('TR2 Puissance Active', '#f43f5e', pointCount, amplitude, 470, frequency, minutes),
          TestDataGenerator.generateSineWave('TR2 Puissance Réactive', '#f59e0b', pointCount, amplitude * 0.3, 110, frequency * 0.8, minutes)
        ];
      }
      
      return [];
    }

    function loadSavedTimeRanges() {
      const charts = ['tr1-power', 'tr2-power'];
      
      charts.forEach(chartId => {
        try {
          const storageKey = `timerange-${chartId}`;
          const savedMinutes = localStorage.getItem(storageKey);
          
          if (savedMinutes) {
            const select = document.querySelector(`select[onchange*="${chartId}"]`);
            if (select) {
              select.value = savedMinutes;
              console.log(`📥 Base de temps restaurée pour ${chartId}: ${savedMinutes} min`);
              // Appliquer les données correspondant à cette base de temps
              loadChartsWithTimeRange(chartId, parseInt(savedMinutes));
            }
          }
        } catch (error) {
          console.warn(`⚠️ Erreur restauration localStorage pour ${chartId}:`, error);
        }
      });
    }

    // Fonction pour vider le localStorage (Debug)
    window.clearLocalStorage = () => {
      try {
        const persistenceService = new PersistenceService();
        const stats = persistenceService.getStats();
        
        if (confirm(`Vider le localStorage ?\n\n` +
                   `Charts: ${stats.chartCount}\n` +
                   `Taille: ${(stats.storageSize / 1024).toFixed(1)} KB\n` +
                   `Dernière MAJ: ${stats.lastUpdated ? new Date(stats.lastUpdated).toLocaleString() : 'Jamais'}`)) {
          
          persistenceService.clearAllState();
          
          // Afficher confirmation
          const notification = document.createElement('div');
          notification.innerHTML = '✅ localStorage vidé !';
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 999999;
            font-weight: 500;
          `;
          
          document.body.appendChild(notification);
          setTimeout(() => document.body.removeChild(notification), 3000);
          
          // Recharger la page pour voir l'effet
          setTimeout(() => location.reload(), 1000);
        }
      } catch (error) {
        console.error('Erreur vidage localStorage:', error);
        alert('Erreur lors du vidage du localStorage');
      }
    };

    // Fonction Settings globale
    window.openSettings = () => {
      console.log('⚙️ Ouverture des paramètres globaux');
      
      // Créer une modal simple pour les paramètres
      const existingModal = document.getElementById('settings-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const modal = document.createElement('div');
      modal.id = 'settings-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      modal.innerHTML = `
        <div style="
          background: #1e293b;
          border: 1px solid #334155;
          border-radius: 12px;
          padding: 2rem;
          max-width: 500px;
          width: 90%;
          color: white;
        ">
          <h3 style="margin: 0 0 1rem 0; font-size: 1.5rem; color: #e2e8f0;">⚙️ Paramètres</h3>
          <div style="margin-bottom: 1.5rem; line-height: 1.6;">
            <p><strong>Interactions :</strong></p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
              <li>Clic + glisser = Pan horizontal</li>
              <li>Molette sur courbe = Zoom X</li>
              <li>Molette sur axe = Zoom Y</li>
              <li>Pincement tactile = Zoom X/Y</li>
              <li>Survol = Crosshair vertical</li>
              <li><strong>Clic droit = Menu contextuel signaux</strong></li>
            </ul>
            
            <p><strong>Menu Contextuel :</strong></p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
              <li><strong>Sélection multi-signaux</strong> (checkboxes)</li>
              <li>Signaux groupés par catégorie</li>
              <li>Navigation clavier (Tab/Flèches/Enter/Escape)</li>
              <li>Boutons "Tout/Rien" pour sélection rapide</li>
              <li><strong>Préservation du zoom actuel</strong></li>
            </ul>
            
            <p><strong>Tooltips :</strong></p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
              <li>Format HH:mm:ss garanti</li>
              <li>Unités précises (kW, V, A, etc.)</li>
              <li>Valeurs adaptatives (kW → MW si > 1000)</li>
              <li>Format français (espaces pour milliers)</li>
            </ul>
            
            <p><strong>Boutons :</strong></p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
              <li>Reset = Vue d'origine</li>
              <li>Export = PNG horodaté</li>
            </ul>
            
            <p style="margin-top: 1rem;"><strong>Version :</strong> Étape 4 - Menu Contextuel Signaux</p>
          </div>
          <button onclick="document.getElementById('settings-modal').remove()" style="
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            font-size: 1rem;
          ">Fermer</button>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Fermer avec clic sur overlay
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
      
      // Fermer avec Escape
      const handleKeydown = (e) => {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', handleKeydown);
        }
      };
      document.addEventListener('keydown', handleKeydown);
    };

    // === INITIALISATION ===
    document.addEventListener('DOMContentLoaded', () => {
      console.log('🚀 Initialisation de la démo des courbes');

      try {
        // Vérifier que Chart.js est chargé
        if (typeof Chart === 'undefined') {
          throw new Error('Chart.js non chargé');
        }

        // Initialiser les deux cartes
        const tr1Instance = initChart('tr1-power', 'chart-tr1-power', {
          options: {
            scales: {
              y: {
                title: {
                  display: true,
                  text: 'Puissance (kW)',
                  color: '#e2e8f0',
                  font: { size: 13, weight: '500' }
                }
              }
            }
          }
        });

        const tr2Instance = initChart('tr2-power', 'chart-tr2-power', {
          options: {
            scales: {
              y: {
                title: {
                  display: true,
                  text: 'Puissance (kW)',
                  color: '#e2e8f0',
                  font: { size: 13, weight: '500' }
                }
              }
            }
          }
        });

        if (!tr1Instance || !tr2Instance) {
          throw new Error('Impossible d\'initialiser les courbes');
        }

        // Charger des données de test
        console.log('📊 Chargement des données de test...');
        
        updateChart('tr1-power', TestDataGenerator.generateTR1Data());
        updateChart('tr2-power', TestDataGenerator.generateTR2Data());

        // Mettre à jour le timestamp
        const updateTime = () => {
          const now = new Date();
          document.getElementById('last-update').textContent = now.toLocaleTimeString('fr-FR');
        };
        updateTime();
        setInterval(updateTime, 1000);

        console.log('✅ Démo initialisée avec succès');
        
        // Charger les bases de temps sauvées après initialisation
        setTimeout(() => {
          loadSavedTimeRanges();
        }, 500);

      } catch (error) {
        console.error('❌ Erreur lors de l\'initialisation:', error);
        alert('Erreur d\'initialisation - Consultez la console pour plus de détails');
      }
    });
  </script>
</body>
</html>
